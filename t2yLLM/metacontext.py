from .config.yamlConfigLoader import Loader
from .LangLoader import LangLoader
from rapidfuzz import process, fuzz
from difflib import SequenceMatcher
import difflib
import wikipedia
import spacy
import os
import sys
from pathlib import Path
import subprocess
from datetime import datetime
import re
import time
import logging
import requests
from collections import Counter

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))


# pokemon searches

# correctly formatting json generated by the LLM
# saving a lot of headaches
# from json_repair import repair_json
#
# CONFIG

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[  # logging.FileHandler("/tmp/LLMStreamer.log"),
        logging.StreamHandler()
    ],
)
logger = logging.getLogger("LLMStreamer")

CONFIG = Loader().loadChatConfig()

UDP_IP = CONFIG.network.RCV_CMD_IP
UDP_PORT = CONFIG.network.RCV_CMD_PORT
BUFFER_SIZE = CONFIG.network.BUFFER_SIZE
AUTHORIZED_IPS = CONFIG.network.AUTHORIZED_IPS


class MetaSearch:
    def __init__(self):
        package_dir = Path(__file__).parent
        try:
            self.langloader = LangLoader()
        except Exception:
            # make a dummy default
            self.langloader = None
        try:
            if CONFIG.general.lang == "fr":
                self.nlp = spacy.load(CONFIG.llms.spacy_model)
                # spacy is kinda very fast but sadly limited in french compared to
                # its english counterpart
            else:
                self.nlp = spacy.load(CONFIG.llms.spacy_model_en)
        except Exception:
            if CONFIG.general.lang == "fr":
                print("downloading model Spacy model")
                os.system(
                    f"python -m spacy download {CONFIG.llms.spacy_model}")
                self.nlp = spacy.load(CONFIG.llms.spacy_model)
            else:
                print("downloading model Spacy model")
                os.system(
                    f"python -m spacy download {CONFIG.llms.spacy_model_en}")
                self.nlp = spacy.load(CONFIG.llms.spacy_model_en)

        self.pokejson = ""
        self.wiki_query = False
        if CONFIG.general.lang == "fr":
            pokemon_file = package_dir / CONFIG.pokemon.pokemon_list
            self.pokemon_list = self.load_pokemon_list(str(pokemon_file))
        else:
            pokemon_file = package_dir / CONFIG.pokemon.pokemon_list_en
            self.pokemon_list = self.load_pokemon_list(str(pokemon_file))
        self.pokemon_phonetics = self.load_pokemon_list(
            str(package_dir / CONFIG.pokemon.pokemon_phonetics)
        )
        self.pokemon_query = False
        self.pokemon_name = ""

        self.wiki_query = False
        self.weather_query = False
        self.date_query = False
        self.location_query = False
        self.time_query = False

    # POKEMON
    def load_pokemon_list(self, filename):
        """
         loads the full pokedex from the text file,
        it is in french but can be changed ofc.
        one pokemon name per line
        It is also possible to create a local json db
        """
        try:
            with open(filename, "r", encoding="utf-8") as file:
                pokemon_names = [line.strip() for line in file if line.strip()]

            return pokemon_names
        except FileNotFoundError:
            print(f"{filename} doesnt seems to exist\nplease create a pokemon file")
            return []
        except Exception as e:
            print(f"Error Loading {filename}: {e}")
            return []

    def search_pokemon_tyradex(self, pokemon_name):
        """
        Uses french API Tyradex, can be change, but no
        switch implemented for english atm
        """
        if CONFIG.general.lang != "fr":
            result = PokeAPIFunctions.search_pokemon_pokeapi(pokemon_name)
            if result["success"]:
                self.pokejson = result["PokeAPI"]
            return result

        else:
            try:
                url = f"https://tyradex.vercel.app/api/v1/pokemon/{
                    pokemon_name}"

                headers = {
                    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
                }
                response = requests.get(url, headers=headers, timeout=10)

                if response.status_code != 200:
                    return {
                        "success": False,
                        "error": f"Pokémon non trouvé sur Tyradex (statut: {response.status_code})",
                    }

                self.pokejson = response.json()
                print(f"Tyradex data : {self.pokejson}")

                if "data" not in self.pokejson or not self.pokejson["data"]:
                    return {
                        "success": False,
                        "error": "Données non disponibles pour ce Pokémon.",
                    }

                return {"success": True, "Tyradex": self.pokejson}
            except Exception as e:
                return {
                    "success": False,
                    "error": f"Erreur lors de la recherche Tyradex: {str(e)}",
                }

    def translate_pokeinfo(self):
        """
        translates JSON from Tyradex into
        text that the LLM can process as context
        """
        if CONFIG.general.lang != "fr":
            return PokeAPIFunctions.translate_pokeinfo_from_pokeapi(
                self.pokejson,
                lang=CONFIG.general.lang
                if CONFIG.general.lang in ["en", "es", "de", "it"]
                else "en",
            )
        else:
            json_data = self.pokejson
            if not json_data:
                return "Aucune donnée disponible pour ce Pokémon."
            else:
                try:
                    # Extraction des informations de base
                    name_fr = json_data.get("name", {}).get("fr", "Inconnu")
                    pokedex_id = json_data.get("pokedex_id", "Inconnu")
                    category = json_data.get("category", "Inconnu")
                    generation = json_data.get("generation", "Inconnu")

                    # Construction
                    description = f"{name_fr} est un Pokémon de type "

                    # Types
                    types = json_data.get("types", [])
                    type_names = [type_info.get("name", "")
                                  for type_info in types]
                    if len(type_names) == 1:
                        description += f"{type_names[0]}"
                    elif len(type_names) == 2:
                        description += f"{type_names[0]} et {type_names[1]}"
                    else:
                        description += (
                            ", ".join(type_names[:-1]) +
                            f" et {type_names[-1]}"
                        )

                    # Numéro du Pokédex
                    description += f". Il porte le numéro {
                        pokedex_id} du Pokédex"
                    if generation:
                        description += f" et est apparu dans la génération {
                            generation}"
                    description += "."

                    # Catégorie
                    if category and category != "Inconnu":
                        description += f" Il est connu comme le {category}."

                    # Caractéristiques physiques
                    try:
                        height = json_data.get("height", "Inconnu")
                        weight = json_data.get("weight", "Inconnu")
                        description += f" Il mesure {height} et pèse {weight}."
                    except AttributeError or NameError:
                        pass

                    # Talents
                    try:
                        talents = json_data.get("talents", []) or []
                        if talents:
                            talent_names = []
                            tc_talents = []

                            for talent in talents:
                                name = talent.get("name", "")
                                is_tc = talent.get("tc", False)

                                if is_tc:
                                    tc_talents.append(name)
                                else:
                                    talent_names.append(name)

                            if talent_names:
                                description += (
                                    f" Ses talents sont : {
                                        ', '.join(talent_names)}"
                                )

                                if tc_talents:
                                    description += f" et il possède le talent caché : {
                                        ', '.join(tc_talents)
                                    }"
                                description += "."
                            elif tc_talents:
                                description += f" Il possède uniquement le talent caché : {
                                    ', '.join(tc_talents)
                                }."
                    except AttributeError or NameError:
                        pass

                    # Statistiques
                    try:
                        stats = json_data.get("stats", {}) or {}
                        if stats:
                            description += f" Ses statistiques de base sont : {
                                stats.get('hp', 0)
                            } PV, "
                            description += f"{stats.get('atk', 0)} en Attaque, {
                                stats.get('def', 0)
                            } en Défense, "
                            description += f"{
                                stats.get('spe_atk', 0)
                            } en Attaque Spéciale, {
                                stats.get('spe_def', 0)
                            } en Défense Spéciale "
                            description += f"et {stats.get('vit', 0)
                                                 } en Vitesse."
                    except AttributeError or NameError:
                        pass

                    # Évolutions
                    try:
                        evolution = json_data.get("evolution", {})
                    except AttributeError:
                        pass

                    # Pré-évolutions
                    try:
                        pre_evolutions = evolution.get("pre", []) or []
                        if pre_evolutions:
                            pre_evo = pre_evolutions[
                                0
                            ]  # On prend la première pré-évolution
                            pre_name = pre_evo.get("name", "")
                            pre_condition = pre_evo.get("condition", "")

                            if pre_name and pre_condition:
                                description += f" {name_fr} est l'évolution de {
                                    pre_name
                                } ({pre_condition})."
                    except AttributeError or NameError:
                        pass

                    # Autres évolutions
                    try:
                        next_evolutions = evolution.get("next", []) or []
                        if next_evolutions:
                            next_evo = next_evolutions[
                                0
                            ]  # On prend la première évolution suivante
                            next_name = next_evo.get("name", "")
                            next_condition = next_evo.get("condition", "")

                            if next_name and next_condition:
                                description += (
                                    f" Il évolue en {
                                        next_name} ({next_condition})."
                                )
                    except AttributeError or NameError:
                        pass

                    # Méga-évolution
                    try:
                        mega = evolution.get("mega", None)
                        if mega:
                            description += " Il possède une méga-évolution."
                    except AttributeError or NameError:
                        pass

                    # Taux de capture
                    try:
                        catch_rate = json_data.get("catch_rate", None)
                        if catch_rate is not None:
                            description += f" Son taux de capture est de {
                                catch_rate}."
                    except AttributeError or NameError:
                        pass

                    # Répartition male / femelle
                    try:
                        sexe = json_data.get("sexe", {}) or {}
                        male_rate = sexe.get("male", 0)
                        female_rate = sexe.get("female", 0)

                        if male_rate > 0 and female_rate > 0:
                            description += f" La répartition des sexes est de {
                                male_rate
                            }% de mâles et {female_rate}% de femelles."
                        elif male_rate == 0 and female_rate == 0:
                            description += " Ce Pokémon est asexué."
                        elif male_rate == 0:
                            description += " Ce Pokémon est exclusivement femelle."
                        elif female_rate == 0:
                            description += " Ce Pokémon est exclusivement mâle."
                    except AttributeError or NameError:
                        pass

                    # Groupes d'œufs
                    try:
                        egg_groups = json_data.get("egg_groups", [])
                        if egg_groups:
                            if len(egg_groups) == 1:
                                description += (
                                    f" Il appartient au groupe d'œuf {
                                        egg_groups[0]}."
                                )
                            else:
                                description += f" Il appartient aux groupes d'œufs {
                                    ' et '.join(egg_groups)
                                }."
                    except AttributeError or NameError:
                        pass

                    # Résistances
                    try:
                        resistances = json_data.get("resistances", [])

                        weaknesses = []
                        strengths = []
                        immunities = []

                        for res in resistances:
                            type_name = res.get("name", "")
                            multiplier = res.get("multiplier", 1)

                            if multiplier > 1:
                                weaknesses.append(
                                    f"{type_name} (x{multiplier})")
                            elif multiplier < 1 and multiplier > 0:
                                strengths.append(
                                    f"{type_name} (x{multiplier})")
                            elif multiplier == 0:
                                immunities.append(type_name)

                        if weaknesses:
                            description += f" Il est faible contre les attaques de type {
                                ', '.join(weaknesses)
                            }."

                        if strengths:
                            description += f" Il résiste aux attaques de type {
                                ', '.join(strengths)
                            }."

                        if immunities:
                            description += f" Il est immunisé contre les attaques de type {
                                ', '.join(immunities)
                            }."
                    except AttributeError or NameError:
                        pass

                    # Formes spéciales
                    try:
                        formes = json_data.get("formes", None)
                        if formes:
                            description += " Ce Pokémon possède différentes formes."
                    except AttributeError or NameError:
                        pass

                except (
                    AttributeError or KeyError or IndexError or ValueError or TypeError
                ):
                    description = "info non trouvée sur ce pokémon"
                    self.wiki_query = True

            return description

    def get_ipa_fr(self, word):
        result = subprocess.run(
            [
                "sudo",
                "-u",
                CONFIG.general.unprivileged_user,
                "espeak-ng",
                "-v",
                CONFIG.general.lang,
                "--ipa",
                "-q",
                word,
            ],
            capture_output=True,
            text=True,
        )
        phonetic = re.sub(r"\([a-z]{2,3}\)", "", result.stdout)
        return phonetic.strip()

    def similarity(self, a, b):
        return round(difflib.SequenceMatcher(None, a, b).ratio() * 100, 2)

    def detect_pokephonetics(self, user_input):
        """
        it is not working really well because there isnt really
        something worknig in french (but plenty in english)
        lets say it is not that accurate
        """
        doc = self.nlp(user_input)
        words = [token.text for token in doc if token.pos_ in [
            "NOUN", "VERB", "ADJ"]]
        # more special tokens exist in english but french model is limited

        best_match_index = None
        best_score = 0
        for word in words:
            word_ipa = self.get_ipa_fr(word)

            word_scores = []
            for i, pokemon_ipa in enumerate(self.pokemon_phonetics):
                score = self.similarity(word_ipa, pokemon_ipa)
                word_scores.append((i, score))

            if word_scores:
                word_scores.sort(key=lambda x: x[1], reverse=True)
                index, score = word_scores[0]

                if score > best_score:
                    best_match_index = index
                    best_score = score

        if best_match_index is None:
            return (None, 0)

        return best_match_index, best_score

    def detect_pokemon_in_text(
        self, user_input, threshold=CONFIG.pokemon.pokemon_find_threshold
    ):
        # threshold should be high at the begining but degressive if
        # it finds keywords related to pokemon query kind

        if not self.pokemon_list:
            print("La liste de Pokémon est vide.")
            return False

        words = user_input.split()
        accent_map = str.maketrans("éèêë", "eeee")

        for word in words:
            word = word.translate(accent_map)
            word = word.capitalize()
            matches = process.extract(
                word,
                self.pokemon_list,
                scorer=fuzz.ratio,
                limit=5,
            )
            print(f"matches = : {matches}")
            _, best_score = self.detect_pokephonetics(word)
            if (
                matches
                and (matches[0][1] >= threshold)
                or (
                    (matches[0][1] >= (threshold - 10))
                    and (best_score >= threshold + 4)
                )
            ):
                self.pokemon_query = True
                self.pokemon_name = matches[0][0]
                # return None
                return True

        self.pokemon_query = False
        return False

    # WIKIPEDIA
    def wiki_search(self, search_terms, original_query):
        wikipedia.set_lang(CONFIG.general.lang)

        search_query = search_terms

        try:
            search_results = wikipedia.search(
                search_query, results=CONFIG.wikipedia.wiki_sentence_search_nb
            )

            if not search_results:
                return {
                    "success": False,
                    "error": "Aucun résultat trouvé sur Wikipedia",
                    "query": search_query,
                }

            candidates = []
            for title in search_results:
                try:
                    page = wikipedia.page(title, auto_suggest=False)
                    summary = wikipedia.summary(
                        title,
                        sentences=CONFIG.wikipedia.summary_size,
                        auto_suggest=False,
                    )
                    relevance_score = self.get_wiki_score(
                        title, summary, original_query, search_terms
                    )
                    candidates.append(
                        {
                            "title": page.title,
                            "summary": summary,
                            "url": page.url,
                            "content": page.content[:1000],
                            "relevance": relevance_score,
                        }
                    )

                except (
                    wikipedia.exceptions.DisambiguationError,
                    wikipedia.exceptions.PageError,
                ) as e:
                    print(f"Error searching on Wikipedia {str(e)}")
                    continue
                except Exception as e:
                    print(f"Wiki Error trying with : {title}: {str(e)}")
                    continue

            candidates.sort(key=lambda x: x["relevance"], reverse=True)

            if not candidates:
                return {
                    "success": False,
                    "error": "Pas de contenu pertinent trouvé",
                    "query": search_query,
                }

            best_candidate = candidates[0]
            if best_candidate["relevance"] < 0.3:  # default 4
                return {
                    "success": False,
                    "error": "Résultats peu pertinents pour cette requête",
                    "best_match": best_candidate["title"],
                    "relevance": best_candidate["relevance"],
                    "query": search_query,
                }

            return {
                "success": True,
                "title": best_candidate["title"],
                "summary": best_candidate["summary"],
                "url": best_candidate["url"],
                "relevance": best_candidate["relevance"],
                "query": search_query,
            }

        except Exception as e:
            print(f"Erreur lors de la recherche Wikipedia: {str(e)}")
            return {
                "success": False,
                "error": f"Erreur lors de la recherche: {str(e)}",
                "query": search_query,
            }

    def get_wiki_score(self, title, summary, query, search_terms):
        score = 0.0  # up to 1
        title_lower = title.lower()
        query_lower = query.lower()
        term_in_title_count = sum(
            1 for term in search_terms if term.lower() in title_lower
        )
        title_term_score = term_in_title_count / max(1, len(search_terms))
        score += title_term_score * 0.3  # Le titre est très important
        best_sequence_match = 0

        for term in search_terms:
            sequence_similarity = SequenceMatcher(
                None, term.lower(), title_lower
            ).ratio()
            best_sequence_match = max(best_sequence_match, sequence_similarity)

        score += best_sequence_match * 0.4

        summary_lower = summary.lower()

        term_occurrences = sum(
            summary_lower.count(term.lower()) for term in search_terms
        )
        summary_term_score = min(1.0, term_occurrences / 5)
        score += summary_term_score * 0.2
        query_words = set(query_lower.split())
        common_words = sum(
            1 for word in query_words if word in summary_lower and len(word) > 3
        )
        context_score = min(1.0, common_words / max(5, len(query_words)))
        score += context_score * 0.1

        if len(summary) < 100:
            score -= 0.1

        return max(0.0, min(1.0, score))

    # LOCATION
    def get_location_name(self, user_input):
        doc = self.nlp(user_input)
        potential_locations = []
        best_location = None

        for ent in doc.ents:
            if ent.label_ == "LOC":
                potential_locations.append(ent.text)

        location_prepositions = [
            "à",
            "en",
            "au",
            "aux",
            "sur",
            "près de",
            "vers",
            "dans",
        ]
        for i, token in enumerate(doc):
            if token.text.lower() in location_prepositions and i < len(doc) - 1:
                span_start = i + 1
                span_end = span_start + 1

                while span_end < len(doc) and (
                    # only that is available in french with spacy
                    # much reduced from english version
                    doc[span_end].pos_ in ["PROPN", "NOUN", "ADJ"]
                    or doc[span_end].text
                    in ["de", "du", "des", "le", "la", "les", "l'"]
                ):
                    span_end += 1

                if span_end > span_start:
                    location_phrase = doc[span_start:span_end].text
                    if location_phrase and location_phrase not in potential_locations:
                        potential_locations.append(location_phrase)

        for location in potential_locations:
            coords = self.get_location_coords(location)

            if coords and "display_name" in coords:
                display_parts = coords["display_name"].split(", ")
                city_name = location

                if len(display_parts) > 1:
                    if len(display_parts[0]) < 3 and len(display_parts) > 1:
                        city_name = display_parts[1]
                    else:
                        city_name = display_parts[0]

                if len(display_parts) > 3 and any(
                    country_indicator in coords["display_name"].lower()
                    for country_indicator in [
                        "france",
                        "suisse",
                        "allemagne",
                        "italie",
                        "espagne",
                    ]
                ):
                    reverse_geo = self.reverse_geocode(
                        coords["lat"], coords["lon"])
                    if reverse_geo and "address" in reverse_geo:
                        address = reverse_geo["address"]
                        city_name = address.get(
                            "city",
                            address.get("town", address.get(
                                "village", city_name)),
                        )

                best_location = {
                    "name": city_name,
                    "original": location,
                    "coords": coords,
                    "confidence": 1.0,
                }

                break

        if not best_location or not coords:
            return False

        return best_location["name"]

    def get_location(self):
        try:
            response = requests.get("https://ipapi.co/json/", timeout=5)
            if response.status_code == 200:
                data = response.json()
                return {
                    "city": data.get("city", "Inconnue"),
                    "region": data.get("region", "Inconnue"),
                    "country": data.get("country_name", "Inconnu"),
                    "latitude": data.get("latitude"),
                    "longitude": data.get("longitude"),
                }
            return {"city": "Inconnue", "region": "Inconnue", "country": "Inconnu"}
        except Exception as e:
            print(f"Erreur de localisation: {e}")
            return {"city": "Inconnue", "region": "Inconnue", "country": "Inconnu"}

    def get_location_coords(self, location_name):
        try:
            url = f"https://nominatim.openstreetmap.org/search?q={
                location_name
            }&format=json&limit=1"
            if CONFIG.general.lang == "fr":
                headers = {
                    "User-Agent": "LLMAssistant/1.0",
                    "Accept-Language": "fr-FR,fr;q=0.9",
                }
            else:
                headers = {
                    "User-Agent": "LLMAssistant/1.0",
                    "Accept-Language": "en-US,en;q=0.9",
                }

            response = requests.get(url, headers=headers, timeout=5)
            if response.status_code == 200:
                data = response.json()
                if data and len(data) > 0:
                    return {
                        "lat": float(data[0]["lat"]),
                        "lon": float(data[0]["lon"]),
                        "display_name": data[0]["display_name"],
                    }
                else:
                    print(f"Lieu non trouvé: {location_name}")
                    return None
            else:
                print(
                    f"Error trying to find corresponding location: {
                        response.status_code
                    }"
                )
                return None
        except Exception as e:
            print(f"Error Goecoding: {e}")

    # WEATHER
    def add_weather(self, user_input, extra_info, query_type):
        location_name = None
        weather_analysis = self.need4weather(user_input)

        if weather_analysis["location_entities"]:
            location_name = weather_analysis["location_entities"][0]

        if not location_name:
            loc = self.get_location()
            location_name = loc["city"] if loc["city"] != "Inconnue" else None

        forecast_days = query_type.get("forecast_days", 0)
        forecast_data = self.get_weather_forecast(location_name)

        if forecast_data["success"]:
            if "forecast" in forecast_data and isinstance(
                forecast_data["forecast"], list
            ):
                extra_info["weather_forecast"] = forecast_data
            else:
                transformed_forecast = {
                    "success": True,
                    "location": {
                        "name": location_name or "Inconnue",
                        "coordinates": forecast_data.get(
                            "coordinates", {"lat": 0, "lon": 0}
                        ),
                        "query": {
                            "city": location_name or "Inconnue",
                            "display_name": location_name or "Inconnue",
                            "source": "specified" if location_name else "default",
                        },
                    },
                    "forecast": forecast_data.get("forecast", []),
                    "timestamp": int(time.time()),
                    "source": "OpenWeatherMap",
                    "facts": forecast_data.get("facts", []),
                }
                extra_info["weather_forecast"] = transformed_forecast

            extra_info["forecast_days_requested"] = forecast_days

            if "weekend" in query_type:
                extra_info["forecast_days_requested_weekend"] = query_type.get(
                    "weekend", False
                )

        if forecast_days == 0:
            weather_data = self.return_weather(location_name=location_name)
            if weather_data["success"]:
                extra_info["weather"] = weather_data

    def has_weather(self, extra_info):
        """Vérifie si on dispose d'informations météo"""
        return (
            "weather" in extra_info
            or "weather_forecast" in extra_info
            or (
                "web_search" in extra_info
                and (
                    "weather" in extra_info["web_search"]
                    or "weather_forecast" in extra_info["web_search"]
                )
            )
        )

    def reverse_geocode(self, lat, lon):
        try:
            url = f"https://nominatim.openstreetmap.org/reverse?lat={lat}&lon={
                lon
            }&format=json"
            if CONFIG.general.lang == "fr":
                headers = {
                    "User-Agent": "LLMAssistant/1.0",
                    "Accept-Language": "fr-FR,fr;q=0.9",
                }
            else:
                headers = {
                    "User-Agent": "LLMAssistant/1.0",
                    "Accept-Language": "en-US,en;q=0.9",
                }

            response = requests.get(url, headers=headers, timeout=5)
            if response.status_code == 200:
                return response.json()
            else:
                return None
        except Exception as e:
            print(f"Erreur de géocodage inverse: {e}")
            return None

    def need4weather(self, user_input):
        doc = self.nlp(user_input)

        location_entities = []

        for ent in doc.ents:
            if ent.label_ in ["LOC"]:
                entity_info = {"text": ent.text,
                               "label": ent.label_, "is_known": False}
                location_entities.append(entity_info)

        weather_indicators = {
            "direct_query": False,
            "temporal_context": False,
            "condition_query": False,
            "forecast_query": False,
        }

        if CONFIG.general.lang == "fr":
            weather_keywords = [
                "météo",
                "temps",
                "température",
                "climat",
                "pleut",
                "pluie",
                "neige",
                "ensoleillé",
                "soleil",
                "nuages",
                "nuageux",
                "orage",
                "chaud",
                "froid",
                "humidité",
                "vent",
                "degrés",
                "celsius",
            ]

            temporal_indicators = [
                "aujourd'hui",
                "maintenant",
                "en ce moment",
                "actuellement",
                "demain",
                "ce soir",
                "cette nuit",
                "ce matin",
                "cette après-midi",
                "cette semaine",
                "ce weekend",
                "prochains jours",
            ]

            condition_patterns = [
                "il pleut",
                "il va pleuvoir",
                "il neige",
                "il va neiger",
                "fait-il",
                "fera-t-il",
                "va-t-il faire",
                "est-ce qu'il fait",
                "est-ce qu'il va faire",
                "quelle température",
            ]

            forecast_patterns = [
                "prévisions",
                "prévu",
                "annoncé",
                "demain",
                "prochain",
                "cette semaine",
                "ce weekend",
                "dans les jours à venir",
            ]
        else:  # en
            weather_keywords = [
                "weather",
                "time",
                "temperature",
                "climate",
                "raining",
                "rain",
                "snow",
                "sunny",
                "sun",
                "clouds",
                "cloudy",
                "storm",
                "hot",
                "cold",
                "humidity",
                "wind",
                "degrees",
                "celsius",
            ]

            temporal_indicators = [
                "today",
                "now",
                "right now",
                "currently",
                "tomorrow",
                "tonight",
                "this night",
                "this morning",
                "this afternoon",
                "this week",
                "this weekend",
                "next few days",
            ]

            condition_patterns = [
                "it's raining",
                "it will rain",
                "it's snowing",
                "it will snow",
                "is it",
                "will it be",
                "is it going to be",
                "is it",
                "is it going to be",
                "what temperature",
            ]

            forecast_patterns = [
                "forecast",
                "expected",
                "announced",
                "tomorrow",
                "next",
                "this week",
                "this weekend",
                "in the coming days",
            ]

        if any(keyword in user_input.lower() for keyword in weather_keywords):
            weather_indicators["direct_query"] = True
        if any(indicator in user_input.lower() for indicator in temporal_indicators):
            weather_indicators["temporal_context"] = True
        if any(pattern in user_input.lower() for pattern in condition_patterns):
            weather_indicators["condition_query"] = True
        if any(pattern in user_input.lower() for pattern in forecast_patterns):
            weather_indicators["forecast_query"] = True

        weather_necessity = 0.0

        if weather_indicators["direct_query"]:
            weather_necessity += 0.4
        if weather_indicators["temporal_context"]:
            weather_necessity += 0.2
        if weather_indicators["condition_query"]:
            weather_necessity += 0.3
        if weather_indicators["forecast_query"]:
            weather_necessity += 0.3

        weather_necessity += min(0.3, len(location_entities) * 0.2)

        location_terms = []

        if location_entities:
            for entity in location_entities:
                location_terms.append(entity["text"])
        else:
            for chunk in doc.noun_chunks:
                if len(chunk.text) > 3 and not any(
                    keyword in chunk.text.lower() for keyword in weather_keywords
                ):
                    location_terms.append(chunk.text)
                    if len(location_terms) >= 2:  # Limiter à 2 termes
                        break

        result = {
            "requires_weather": weather_necessity >= 0.3,
            "weather_necessity_score": weather_necessity,
            "weather_indicators": weather_indicators,
            "location_entities": [e["text"] for e in location_entities],
            "location_terms": location_terms[:2],
            "default_location": len(location_terms) == 0,
        }

        return result

    def return_weather(
        self, query=None, location_terms=None, lat=None, lon=None, location_name=None
    ):
        """
        gets current weather data from OpenWeatherMap API.
        """
        try:
            location = None
            coordinates = None

            if lat is not None and lon is not None:
                coordinates = {"lat": lat, "lon": lon}
                location = {"source": "coordinates", "lat": lat, "lon": lon}

                try:
                    reverse_geocode = self.reverse_geocode(lat, lon)
                    if reverse_geocode and "display_name" in reverse_geocode:
                        location["city"] = reverse_geocode.get(
                            "display_name", "Unknown location"
                        )
                except Exception as e:
                    print(f"Reverse Geolocation failed : {str(e)}")
                    location["city"] = CONFIG.location.default_location

            elif location_name:
                coords = self.get_location_coords(location_name)
                if coords:
                    coordinates = {"lat": coords["lat"], "lon": coords["lon"]}
                    location = {
                        "city": location_name,
                        "display_name": coords.get("display_name", location_name),
                        "source": "specified",
                    }

            elif location_terms and len(location_terms) > 0:
                for term in location_terms:
                    coords = self.get_location_coords(term)
                    if coords:
                        coordinates = {
                            "lat": coords["lat"], "lon": coords["lon"]}
                        location = {
                            "city": term,
                            "display_name": coords.get("display_name", term),
                            "source": "query",
                        }
                        break

            if not coordinates:
                default_location = self.get_location()
                location = {
                    "city": default_location.get("city", "Inconnue"),
                    "region": default_location.get("region", ""),
                    "country": default_location.get("country", ""),
                    "source": "default",
                }
                coordinates = {
                    "lat": default_location.get(
                        "latitude", CONFIG.location.default_latitude
                    ),
                    "lon": default_location.get(
                        "longitude", CONFIG.location.default_longitude
                    ),
                }

            api_key = self.openWeatherKey()
            if not api_key:
                return {
                    "success": False,
                    "error": "No OpenWeatherMap API key configured",
                    "location": location,
                    "query": query,
                }

            url = f"https://api.openweathermap.org/data/2.5/weather?lat={
                coordinates['lat']
            }&lon={coordinates['lon']}&appid={api_key}&units=metric&lang=fr"
            response = requests.get(
                url,
                timeout=CONFIG.weather.api_timeout
                if hasattr(CONFIG.weather, "api_timeout")
                else 5,
            )

            if response.status_code != 200:
                return {
                    "success": False,
                    "error": f"Error from weather API (code {response.status_code})",
                    "location": location,
                    "query": query,
                }

            data = response.json()

            weather_data = {
                "success": True,
                "temperature": data["main"]["temp"],
                "feels_like": data["main"]["feels_like"],
                "min_temp": data["main"]["temp_min"],
                "max_temp": data["main"]["temp_max"],
                "pressure": data["main"]["pressure"],
                "humidity": data["main"]["humidity"],
                "description": data["weather"][0]["description"],
                "icon": data["weather"][0]["icon"],
                "main": data["weather"][0]["main"],
                "wind_speed": data.get("wind", {}).get("speed", 0),
                "wind_direction": data.get("wind", {}).get("deg", 0),
                "clouds": data.get("clouds", {}).get("all", 0),
                "visibility": data.get("visibility", 0),
                "location": {
                    "name": data.get("name", location.get("city", "Inconnue")),
                    "country": data.get("sys", {}).get("country", ""),
                    "sunrise": data.get("sys", {}).get("sunrise", 0),
                    "sunset": data.get("sys", {}).get("sunset", 0),
                    "timezone": data.get("timezone", 0),
                },
                "query_location": location,
                "coordinates": coordinates,
                "timestamp": int(time.time()),
            }

            if query:
                weather_data["query"] = query
                relevance_score = self.get_weather_score(
                    weather_data, query, location_terms
                )
                weather_data["relevance"] = relevance_score

            return weather_data

        except Exception as e:
            print(f"Error getting weather data : {e}")
            return {
                "success": False,
                "error": f"Error: {str(e)}",
                "location": location
                if location
                else {"city": "Unknown", "source": "error"},
                "query": query,
            }

    def get_weather_score(self, weather_data, query, location_terms=None):
        score = 0.6  # High basis

        location_match_score = 0.0

        if weather_data["query_location"]["source"] == "query":
            location_match_score = 0.3
        else:
            location_match_score = 0.1

        score += location_match_score

        current_time = int(time.time())
        data_age = current_time - weather_data["timestamp"]

        if data_age < 1800:
            score += 0.1

        query_lower = query.lower()

        weather_main = weather_data["main"].lower()
        weather_desc = weather_data["description"].lower()

        if CONFIG.general.lang == "fr":
            condition_matches = {
                "pluie": ["pluie", "pluvieux"],
                "neige": ["neige", "neigeux"],
                "nuage": ["nuage", "nuageux"],
                "soleil": ["soleil", "ensoleillé"],
                "orage": ["orage", "orageux"],
                "brouillard": ["brouillard", "brume"],
            }
        else:
            condition_matches = {
                "rain": ["rain", "rainy", "raining"],
                "snow": ["snow", "snowy", "snowing"],
                "cloud": ["cloud", "cloudy"],
                "sun": ["sun", "sunny", "sunshine"],
                "storm": ["storm", "stormy", "thunderstorm"],
                "fog": ["fog", "foggy", "mist"],
            }

        for condition_term, condition_values in condition_matches.items():
            if condition_term in query_lower:
                if any(
                    val in weather_main or val in weather_desc
                    for val in condition_values
                ):
                    score += 0.2
                    break

        if CONFIG.general.lang == "fr":
            temp_patterns = {
                "chaud": lambda t: t > 25,
                "chaleur": lambda t: t > 25,
                "froid": lambda t: t < 10,
                "frais": lambda t: t < 15,
                "gel": lambda t: t <= 0,
                "gelée": lambda t: t <= 0,
                "canicule": lambda t: t > 30,
            }
        else:
            temp_patterns = {
                "hot": lambda t: t > 25,
                "warm": lambda t: t > 20,
                "cold": lambda t: t < 10,
                "cool": lambda t: t < 15,
                "freezing": lambda t: t <= 0,
                "frozen": lambda t: t <= 0,
                "heat wave": lambda t: t > 30,
            }

        current_temp = weather_data["temperature"]

        for temp_term, condition in temp_patterns.items():
            if temp_term in query_lower and condition(current_temp):
                score += 0.2
                break

        return min(1.0, score)

    def openWeatherKey(self):
        try:
            api_key = os.environ.get("OPENWEATHERMAP_API_KEY")
            return api_key
        except Exception:
            logger.info(
                "Please get an OpenWeatherMap API key if you want to access weather data and\nexport in your envirronement variables"
            )
            return None

    def get_weather_forecast(
        self, location_name=None, days=5
    ):  # max forecast 5 days with openweather
        try:
            coordinates = None
            location = None

            if location_name:
                coords = self.get_location_coords(location_name)
                if coords:
                    coordinates = {"lat": coords["lat"], "lon": coords["lon"]}
                    location = {
                        "city": location_name,
                        "display_name": coords.get("display_name", location_name),
                        "source": "specified",
                    }

            if not coordinates:
                default_location = self.get_location()
                location = {
                    "city": default_location.get("city", "Inconnue"),
                    "region": default_location.get("region", ""),
                    "country": default_location.get("country", ""),
                    "source": "default",
                }
                coordinates = {
                    "lat": default_location.get("latitude", 48.8566),
                    "lon": default_location.get("longitude", 2.3522),
                }

            api_key = self.openWeatherKey()
            url = f"https://api.openweathermap.org/data/2.5/forecast?lat={
                coordinates['lat']
            }&lon={coordinates['lon']}&appid={api_key}&units=metric&lang=fr"

            response = requests.get(url, timeout=5)

            if response.status_code != 200:
                return {
                    "success": False,
                    "error": f"Erreur API prévisions (code {response.status_code})",
                    "location": location,
                }

            data = response.json()
            forecast_by_day = {}
            city_name = data["city"]["name"]

            for item in data["list"]:
                dt = datetime.fromtimestamp(item["dt"])

                date_str = dt.strftime("%Y-%m-%d")
                if date_str not in forecast_by_day:
                    forecast_by_day[date_str] = {
                        "date": date_str,
                        "day_name": dt.strftime("%A"),
                        "min_temp": float("inf"),
                        "max_temp": float("-inf"),
                        "humidity_avg": 0,
                        "pressure_avg": 0,
                        "wind_speed_avg": 0,
                        "descriptions": [],
                        "icons": [],
                        "timestamps": [],
                        "forecast_points": 0,
                    }

                day_data = forecast_by_day[date_str]
                day_data["min_temp"] = min(
                    day_data["min_temp"], item["main"]["temp_min"]
                )
                day_data["max_temp"] = max(
                    day_data["max_temp"], item["main"]["temp_max"]
                )
                day_data["humidity_avg"] += item["main"]["humidity"]
                day_data["pressure_avg"] += item["main"]["pressure"]
                day_data["wind_speed_avg"] += item["wind"]["speed"]
                day_data["descriptions"].append(
                    item["weather"][0]["description"])
                day_data["icons"].append(item["weather"][0]["icon"])
                day_data["timestamps"].append(item["dt"])
                day_data["forecast_points"] += 1

            daily_forecasts = []

            for date_str, day_data in sorted(forecast_by_day.items()):
                if day_data["forecast_points"] > 0:
                    day_data["humidity_avg"] /= day_data["forecast_points"]
                    day_data["pressure_avg"] /= day_data["forecast_points"]
                    day_data["wind_speed_avg"] /= day_data["forecast_points"]

                desc_counter = Counter(day_data["descriptions"])
                day_data["main_description"] = desc_counter.most_common(1)[
                    0][0]
                icon_counter = Counter(day_data["icons"])
                day_data["main_icon"] = icon_counter.most_common(1)[0][0]
                del day_data["descriptions"]
                del day_data["icons"]

                daily_forecasts.append(day_data)

            result = {
                "success": True,
                "location": {
                    "name": city_name,
                    "coordinates": coordinates,
                    "query": location,
                },
                "forecast": daily_forecasts[:days],
                "timestamp": int(time.time()),
                "source": "OpenWeatherMap",
            }
            return result

        except Exception as e:
            print(f"Error in weather forecast: {e}")
            return {
                "success": False,
                "error": f"Erreur: {str(e)}",
                "location": location
                if location
                else {"city": "Unknown", "source": "error"},
            }

    # GENERAL
    def classify_query(self, user_input):
        """Détecte le type de requête"""
        user_input_lower = user_input.lower()
        query_type = {
            "weather": False,
            "time": False,
            "date": False,
            "location": False,
            "pokemon": self.pokemon_query,
            "forecast_days": 0,
        }

        if CONFIG.general.lang == "fr":
            weather_keywords = [
                "météo",
                "temps qu'il fait",
                "température",
                "climat",
                "pleut",
                "froid",
                "neige",
                "pluie",
                "ensoleillé",
                "soleil",
                "nuages",
                "demain",
                "prévisions",
                "prévision",
                "fera-t-il",
                "fera t-il",
                "temps fera",
                "va-t-il faire",
                "quel temps",
                "temps sera",
                "sera-t-il",
                "sera t-il",
            ]
            time_keywords = ["heure", "quelle heure"]
            date_keywords = [
                "date",
                "jour",
                "quel jour",
                "on est quel jour",
                "aujourd'hui",
                "quelle date",
                "calendrier",
            ]
            location_keywords = [
                "où suis-je",
                "ma position",
                "ma localisation",
                "ville",
            ]

            week_days = {
                "lundi": 0,
                "mardi": 1,
                "mercredi": 2,
                "jeudi": 3,
                "vendredi": 4,
                "samedi": 5,
                "dimanche": 6,
            }
        else:
            weather_keywords = [
                "weather",
                "what's the weather",
                "temperature",
                "climate",
                "raining",
                "cold",
                "snow",
                "rain",
                "sunny",
                "sun",
                "clouds",
                "tomorrow",
                "forecast",
                "prediction",
                "will it be",
                "what will the weather be",
                "is it going to be",
                "what's the weather",
                "weather will be",
            ]
            time_keywords = ["time", "what time"]
            date_keywords = [
                "date",
                "day",
                "what day",
                "what day is it",
                "today",
                "what's the date",
                "calendar",
            ]
            location_keywords = ["where am I",
                                 "my position", "my location", "city"]

            week_days = {
                "monday": 0,
                "tuesday": 1,
                "wednesday": 2,
                "thursday": 3,
                "friday": 4,
                "saturday": 5,
                "sunday": 6,
            }

        try:
            query_type["weather"] = any(
                keyword in user_input_lower for keyword in weather_keywords
            )
        except KeyError:
            pass
        try:
            query_type["time"] = any(
                keyword in user_input_lower for keyword in time_keywords
            )
        except KeyError:
            pass
        try:
            query_type["date"] = any(
                keyword in user_input_lower for keyword in date_keywords
            )
        except KeyError:
            pass
        try:
            query_type["location"] = any(
                keyword in user_input_lower for keyword in location_keywords
            ) or self.get_location_name(user_input)
        except IndexError:
            pass

        self.weather_query = query_type["weather"]
        self.date_query = query_type["date"]
        self.location_query = query_type["location"]
        self.time_query = query_type["time"]

        if query_type["weather"]:
            if "aujourd'hui" in user_input_lower:
                query_type["forecast_days"] = 0
            elif "demain" in user_input_lower:
                query_type["forecast_days"] = 1
            elif (
                "après-demain" in user_input_lower or "après demain" in user_input_lower
            ):
                query_type["forecast_days"] = 2

            for i in range(2, 5):
                if f"dans {i} jour" in user_input_lower:
                    query_type["forecast_days"] = i
                    break

            today = datetime.now().weekday()  # 0=monday, 6=sunday
            if "week-end" in user_input_lower or "weekend" in user_input_lower:
                if "ce" in user_input_lower:
                    days_to_saturday = (5 - today) % 7
                    if days_to_saturday == 0 and datetime.now().hour >= 18:
                        query_type["forecast_days"] = 1
                    else:
                        query_type["forecast_days"] = days_to_saturday
                    query_type["weekend"] = True

            for index in week_days.keys():
                if index in user_input_lower:
                    # print(f"index : {index}")
                    index_num = week_days[index]
                    # print(f"index_num : {index_num}")
                    if index_num - today > 0:
                        days_diff = index_num - today
                    elif today - index_num > 0:
                        days_diff = 7 - (today - index_num)
                    elif today - index_num == 0:
                        days_diff = 7

                    # print(f"différence en nombre de jours : {days_diff}")
                    query_type["forecast_days"] = days_diff
                    break

            if CONFIG.general.lang == "fr":
                if (
                    "semaine" in user_input_lower
                    or "prochains jours" in user_input_lower
                ):
                    query_type["forecast_days"] = -1
            else:
                if (
                    "week" in user_input_lower
                    or "next days"
                    or "following days" in user_input_lower
                ):
                    query_type["forecast_days"] = -1

        return query_type

    def get_info(self, query_type, user_input):
        extra_info = {}

        if query_type["location"]:
            extra_info["location"] = self.get_location_name(user_input)

        now = datetime.now()
        extra_info["time"] = (
            f"{now.hour} heure{'s' if now.hour > 1 else ''} {now.minute:02d}"
        )

        if CONFIG.general.lang == "fr":
            month_names = [
                "janvier",
                "février",
                "mars",
                "avril",
                "mai",
                "juin",
                "juillet",
                "août",
                "septembre",
                "octobre",
                "novembre",
                "décembre",
            ]
            day_names = [
                "lundi",
                "mardi",
                "mercredi",
                "jeudi",
                "vendredi",
                "samedi",
                "dimanche",
            ]
        else:
            month_names = [
                "january",
                "february",
                "march",
                "april",
                "may",
                "june",
                "july",
                "august",
                "september",
                "october",
                "november",
                "december",
            ]
            day_names = [
                "monday",
                "tuesday",
                "wednesday",
                "thursday",
                "friday",
                "saturday",
                "sunday",
            ]

        day_of_week = day_names[now.weekday()]
        month_name = month_names[now.month - 1]
        extra_info["date"] = f"{day_of_week} {now.day} {month_name} {now.year}"

        return extra_info

    def update_info(self, user_input, extra_info, web_search_results, query_type):
        if web_search_results:
            extra_info["web_search"] = web_search_results

            if "weather_forecast" in web_search_results:
                extra_info["weather_forecast"] = web_search_results["weather_forecast"]
                extra_info["forecast_days_requested"] = query_type.get(
                    "forecast_days", 0
                )
                print(
                    f"forecast days requested variable : {
                        extra_info['forecast_days_requested']
                    }"
                )
                if "weekend" in query_type:
                    extra_info["forecast_days_requested_weekend"] = query_type.get(
                        "weekend", False
                    )
            if "weather" in web_search_results:
                extra_info["weather"] = web_search_results["weather"]
            if "pokepedia" in web_search_results:
                extra_info["pokemon"] = web_search_results["pokepedia"]

        if query_type["weather"] and not (
            extra_info.get("weather") or extra_info.get("weather_forecast")
        ):
            self.add_weather(user_input, extra_info, query_type)


class PokeAPIFunctions:
    @staticmethod
    def search_pokemon_pokeapi(pokemon_name):
        try:
            pokemon_name = pokemon_name.lower().strip()

            url = f"https://pokeapi.co/api/v2/pokemon/{pokemon_name}"
            headers = {
                "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
            }
            response = requests.get(url, headers=headers, timeout=10)

            if response.status_code != 200:
                return {
                    "success": False,
                    "error": f"Pokemon not found on PokeAPI (status: {response.status_code})",
                }

            pokemon_data = response.json()

            species_url = pokemon_data.get("species", {}).get("url", "")
            species_data = {}
            if species_url:
                species_response = requests.get(
                    species_url, headers=headers, timeout=10
                )
                if species_response.status_code == 200:
                    species_data = species_response.json()

            transformed_data = PokeAPIFunctions._transform_pokeapi_to_tyradex_format(
                pokemon_data, species_data
            )

            return {"success": True, "PokeAPI": transformed_data}

        except Exception as e:
            return {
                "success": False,
                "error": f"Error during PokeAPI search: {str(e)}",
            }

    @staticmethod
    def _transform_pokeapi_to_tyradex_format(pokemon_data, species_data):
        """
        Transform PokeAPI response to match Tyradex structure for compatibility
        """
        # Extract names in different languages
        names = {"en": pokemon_data.get("name", "Unknown").title()}
        if species_data and "names" in species_data:
            for name_entry in species_data["names"]:
                lang = name_entry.get("language", {}).get("name", "")
                if lang == "fr":
                    names["fr"] = name_entry.get("name", names["en"])
                elif lang == "en":
                    names["en"] = name_entry.get("name", names["en"])

        if "fr" not in names:
            names["fr"] = names["en"]

        types = []
        for type_slot in pokemon_data.get("types", []):
            type_name = type_slot.get("type", {}).get("name", "")
            if type_name:
                types.append({"name": type_name.capitalize()})

        abilities = []
        for ability_slot in pokemon_data.get("abilities", []):
            ability_info = ability_slot.get("ability", {})
            is_hidden = ability_slot.get("is_hidden", False)
            abilities.append(
                {
                    "name": ability_info.get("name", "").replace("-", " ").title(),
                    "tc": is_hidden,  # tc = talent caché (hidden ability)
                }
            )

        stats = {}
        stat_mapping = {
            "hp": "hp",
            "attack": "atk",
            "defense": "def",
            "special-attack": "spe_atk",
            "special-defense": "spe_def",
            "speed": "vit",
        }

        for stat in pokemon_data.get("stats", []):
            stat_name = stat.get("stat", {}).get("name", "")
            if stat_name in stat_mapping:
                stats[stat_mapping[stat_name]] = stat.get("base_stat", 0)

        generation_url = species_data.get("generation", {}).get("url", "")
        generation = 1
        if generation_url:
            try:
                generation = int(generation_url.rstrip("/").split("/")[-1])
            except Exception:
                generation = 1

        category = "Pokémon"  # Default
        if species_data and "genera" in species_data:
            for genus in species_data["genera"]:
                if genus.get("language", {}).get("name") == "fr":
                    category = genus.get("genus", "Pokémon")
                    break
                elif (
                    genus.get("language", {}).get("name") == "en"
                    and category == "Pokémon"
                ):
                    category = genus.get("genus", "Pokémon")

        transformed = {
            "name": names,
            "pokedex_id": pokemon_data.get("id", 0),
            "generation": generation,
            "category": category,
            "types": types,
            "talents": abilities,
            "stats": stats,
            # PokeAPI gives decimeters
            "height": f"{pokemon_data.get('height', 0) / 10} m",
            # PokeAPI gives hectograms
            "weight": f"{pokemon_data.get('weight', 0) / 10} kg",
            "catch_rate": species_data.get("capture_rate", None),
            "base_experience": pokemon_data.get("base_experience", None),
        }

        gender_rate = species_data.get("gender_rate", -1)
        if gender_rate >= 0:
            female_rate = (gender_rate / 8) * 100
            male_rate = 100 - female_rate
            transformed["sexe"] = {"male": male_rate, "female": female_rate}
        else:
            transformed["sexe"] = {"male": 0, "female": 0}

        egg_groups = []
        for group in species_data.get("egg_groups", []):
            group_name = group.get("name", "")
            if group_name:
                egg_groups.append(group_name.replace("-", " ").title())
        if egg_groups:
            transformed["egg_groups"] = egg_groups

        transformed["evolution"] = {"pre": [], "next": [], "mega": None}

        transformed["resistances"] = []

        return {"data": transformed}

    @staticmethod
    def translate_pokeinfo_from_pokeapi(pokejson, lang="en"):
        json_data = pokejson
        if not json_data or "data" not in json_data:
            return "No data available for this Pokémon."

        try:
            data = json_data["data"]

            name = data.get("name", {}).get(
                lang, data.get("name", {}).get("en", "Unknown")
            )
            pokedex_id = data.get("pokedex_id", "Unknown")
            category = data.get("category", "Unknown")
            generation = data.get("generation", "Unknown")

            description = f"{name} is a "

            types = data.get("types", [])
            type_names = [type_info.get("name", "") for type_info in types]
            if len(type_names) == 1:
                description += f"{type_names[0]}-type Pokémon"
            elif len(type_names) == 2:
                description += f"{type_names[0]}/{type_names[1]}-type Pokémon"
            else:
                description += "Pokémon"

            description += f". It is number {pokedex_id} in the Pokédex"
            if generation and generation != "Unknown":
                description += f" and first appeared in Generation {
                    generation}"
            description += "."

            if category and category != "Unknown" and category != "Pokémon":
                description += f" It is known as the {category}."

            height = data.get("height", "Unknown")
            weight = data.get("weight", "Unknown")
            if height != "Unknown" and weight != "Unknown":
                description += f" It is {height} tall and weighs {weight}."

            abilities = data.get("talents", []) or []
            if abilities:
                regular_abilities = []
                hidden_abilities = []

                for ability in abilities:
                    name = ability.get("name", "")
                    is_hidden = ability.get("tc", False)

                    if is_hidden:
                        hidden_abilities.append(name)
                    else:
                        regular_abilities.append(name)

                if regular_abilities:
                    description += f" Its abilities are: {
                        ', '.join(regular_abilities)}"

                    if hidden_abilities:
                        description += f", and it has the hidden ability: {
                            ', '.join(hidden_abilities)
                        }"
                    description += "."
                elif hidden_abilities:
                    description += f" It only has the hidden ability: {
                        ', '.join(hidden_abilities)
                    }."

            stats = data.get("stats", {}) or {}
            if stats:
                description += f" Its base stats are: {
                    stats.get('hp', 0)} HP, "
                description += (
                    f"{stats.get('atk', 0)} Attack, {
                        stats.get('def', 0)} Defense, "
                )
                description += f"{stats.get('spe_atk', 0)} Special Attack, {
                    stats.get('spe_def', 0)
                } Special Defense, "
                description += f"and {stats.get('vit', 0)} Speed."

            catch_rate = data.get("catch_rate", None)
            if catch_rate is not None:
                description += f" Its catch rate is {catch_rate}."

            sexe = data.get("sexe", {}) or {}
            male_rate = sexe.get("male", 0)
            female_rate = sexe.get("female", 0)

            if male_rate > 0 and female_rate > 0:
                description += f" The gender distribution is {male_rate}% male and {
                    female_rate
                }% female."
            elif male_rate == 0 and female_rate == 0:
                description += " This Pokémon is genderless."
            elif male_rate == 0:
                description += " This Pokémon is exclusively female."
            elif female_rate == 0:
                description += " This Pokémon is exclusively male."

            egg_groups = data.get("egg_groups", [])
            if egg_groups:
                if len(egg_groups) == 1:
                    description += f" It belongs to the {
                        egg_groups[0]} egg group."
                else:
                    description += (
                        f" It belongs to the {
                            ' and '.join(egg_groups)} egg groups."
                    )

        except Exception as e:
            logger.error(f"Error translating PokeAPI info: {str(e)}")
            description = "Information not found for this Pokémon."

        return description
